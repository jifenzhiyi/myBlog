1.HTTP和HTTPS
一.基本概念
HTTP:是互联网上应用最为广泛的一种网络协议，是一个客户端和服务端请求和应答的标准TCP,用于WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少
HTTPS:是以安全为目标的HTTP通道,简单讲就是安全版的HTTP,其中增加了SSL层
HTTPS协议主要作用分两种，一种建立信息安全通道，来保证数据传输的安全，另一种确认网站的真实性

二.区别
HTTP是未加密的而HTTPS是由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议
所以主要区别如下：
a.https协议需要到ca申请证书，一般免费的很少，需要一定的费用
b.http是超文本传输协议，信息是明文的，而https则是具有安全行的ssl加密传输协议
c.http和https使用的连接方式不同，用的端口也不一样，前者80,后者443
d.https比http更安全

三.HTTPS的工作原理
客户端在使用HTTPS方式与Web服务器通信时的步骤:
a.客户使用https的URL地址访问Web服务器，要求与Web服务器建立SSL连接
b.Web服务器收到请求后，会将网站证书信息（证书中包含公钥）传送一份给客户端
c.客户端的浏览器与Web服务器开始协商SSL连接的安全登记，也就是信息加密等级
d.客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话加密，并传送给网站。
e.Web服务器利用自己的私钥解密出会话密钥
f.Web利用会话密钥加密与客户端之间的通信

四.HTTPS的优缺点
优点：
a.使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户机和服务器
b.HTTPS是进行加密传输，身份认证的网络协议，比HTTP更安全，防止数据在传输过程中不被窃取，改变，确保数据的完整性
c.大幅增加了中间人攻击的成本
d.比起同等HTTP网站，在网站搜索结果中的排名会更高
缺点：
a.会使页面加载时间延长50%，增加10%到20%的耗电
b.HTTPS的连接缓存不如HTTP高效，会增加数据开销和功耗
c.SSL证书需要钱，功能越强大的证书越高，个人网站或小网站没必要
d.SSL证书需要绑定IP,不能在同一个IP上绑定多个域名，IPv4资源不可能支撑这个消耗
e.HTTPS的加密范围也比较有限，在黑客攻击，拒绝服务攻击，服务器劫持等方面几乎起不到什么作用.最关键的SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

五.HTTP转HTTPS
首先页面中的所有链接都需要由http转成https,故原有地址不要用绝对地址，而尽量使用相对地址自动适配

2.position的值，relative和absolute分别是相对于谁进行定位的
absolute :生成绝对定位的元素，相对于最近一级的定位不是 static 的父元素来进行定位。
fixed （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。
relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。
static 默认值。没有定位，元素出现在正常的流中
sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出

3.如何解决跨域问题
a.response 添加 header
resp.setHeader("Access-Control-Allow-Origin", "*");
b.JSONP 方式
c.HttpClient 请求转发
d.nginx 转发
利用nginx反向代理，将请求分发到部署到相应项目的tomcat服务器，当然也不存在跨域问题

4.Heap排序的原理？复杂度?
我们一般提到堆排序里的堆指的是二叉堆（binary heap），是一种完全二叉树，二叉堆有两种：最大堆和最小堆
堆调整的时间复杂度是O(log n) 
建堆的时间复杂度是O(n)
堆排序的时间复杂度是O(n log n)

Heap-Sort就是堆排序的接口算法，首先调用build-heap将数组改造成最大堆或者最小堆，然后将堆顶元素和堆底元素进行交换，之后每次将最顶部的元素分离出堆，重复n-1次后，数组排列完成。

5.几种常见的排序算法，手写
<!-- 堆排序，快速排序，归并排序, 插入排序 -->
a.归并排序
```
// 合并两个有序数组
function mergeArr(arr1, arr2) {
  const res = [];
  let idx1 = 0, idx2 = 0;
  while (idx1 < arr1.length && idx2 < arr2.length) {
    if (arr1[idx1] <= arr2[idx2]) {
      res.push(arr1[idx1]);
      idx1++;
    } else {
      res.push(arr2[idx2]);
      idx2++;
    }
  }
  while (idx1 < arr1.length) {
    res.push(arr1[idx1]);
    idx1++;
  }
  while (idx2 < arr2.length) {
    res.push(arr2[idx2]);
    idx2++;
  }
  return res;
}
// 分治
function mergeSort(arr, l, r) {
  if (l < r) {
    let mid = (l + r) >> 1;
    const arr1 = mergeSort(arr, l, mid);
    const arr2 = mergeSort(arr, mid + 1, r);
    return mergeArr(arr1, arr2);
  }
  return [arr[r]];
}
```
b.快速排序
```
// 分区
function partition(arr, start, end) {
  let index = start, item = arr[start]; // 设置起始下标和值
  for (let i = start + 1; i <= end; i++) {
    if (arr[i] < item) {
      index++;
      [arr[index], arr[i]] = [arr[i], arr[index]];
    }
  }
  arr[start] = arr[index];
  arr[index] = item;
  return index;
}
function quick_sort(arr, start, end) {
  if (start < end) {
    const pivotpos = partition(arr, start, end);
    quick_sort(arr, start, pivotpos - 1);
    quick_sort(arr, pivotpos + 1, end);
  }
  return;
}
c.堆排序
class Heap {
  constructor(data, type = 'min') {
    this.data = data;
    this.compartor = (a, b) => type === 'min' ? a - b : b - a;
    this.heapify();
  }
  
  heapify() {
    if (this.size() < 2) return;
    for (let i = 1; i < this.size(); i++) {
      this.bubbleUp(i)
    }
  }

  // 添加
  offer(val) {
    this.data.push(val);
    this.bubbleUp(this.size() - 1); // 从最尾部进行调整
  }

  // 长度
  size() {
    return this.data.length;
  }

  // 查看顶部元素
  peek() {
    return this.size() > 0 ? this.data[0] : null;
  }

  // 弹出顶部元素
  poll() {
    if (!this.size()) return null;
    let res = this.data[0];
    this.data[0] = this.data.pop();
    this.bubbleDown(0);
    return res;
  }

  swap(i, j) {
    [this.data[i], this.data[j]] = [this.data[j], this.data[i]];
  }

  bubbleUp(index) {
    while (index != 0) {
      const parentIndex = (index - 1) >> 1;
      if (this.compartor(this.data[index], this.data[parentIndex]) < 0) {
        this.swap(index, parentIndex);
        index = parentIndex;
      } else {
        break;
      }
    }
  }

  bubbleDown(index) {
    let lastIndex = this.size() - 1;
    while (index < lastIndex) {
      let minIndex = index * 2 + 1;
      if (minIndex < lastIndex
        && this.compartor(this.data[minIndex], this.data[minIndex + 1]) > 0) {
        minIndex = minIndex + 1;
      }
      if (minIndex <= lastIndex
        && this.compartor(this.data[minIndex], this.data[index]) < 0) {
        this.swap(minIndex, index);
        index = minIndex;
      } else {
        break;
      }
    }
  }
}
d.插入排序
function insert_sort(arr, start, end) {
  for (let i = start + 1; i <= end; i++) {
    if (arr[i] < arr[i - 1]) {
      const tmp = arr[i];
      let j = i - 1;
      while (j >= 0 && tmp < arr[j]) {
        arr[j + 1] = arr[j];
        j--;
      }
      arr[j + 1] = tmp;
    }
  }
}
// 备注：如果长度小于25用插入，大于25用快速排序，超级大的用并归排序
```

6.数组的去重，尽可能写出多个方法
```
const arr = [1,1,2,2,3,3,4,5];
// 1.利用Set去重
const res1 = Array.from(new Set(arr)); // 去重后的数组
console.log(res1);
// 2.利用indexOf方法
const res2 = [];
for (let i = 0; i < arr.length; i++) {
  if (res2.indexOf(arr[i]) === -1) res2.push(arr[i]);
}
console.log(res2);
// 3.filter函数
const res3 = arr.filter((ele, index, self) => self.indexOf(ele) === index);
console.log(res3);
// 4.includes
const res4 = [];
for (let n of arr) {
  if (!res4.includes(n)) res4.push(n);
}
console.log(res4);
```

7.如果有一个大的数组，都是整型，怎么找出最大的前10个数
创造一个大小为10的小顶堆，
然后依次插入原数组中的每个数，
当堆的数量达到10的时候，
每次插入之后弹出最顶部的值，
最后堆的结果就是剩余的10个最大数

8.说说你对作用域链的理解
全局作用域只有一个，每个函数又都有作用域（环境）
.编译器运行时会将变量定义在所在作用域
.使用变量时会从当前作用域开始向上查找变量
.作用域就像攀亲亲一样，晚辈总是可以向上辈要些东西

作用域链只向上查找，找到全局window即终止，应该尽量不要在全局作用域中添加变量
函数被执行后其环境变量将从内存中删除
```
// 下面函数在每次执行后将删除函数内部的total变量
function count() {
  let total = 0;
}
count();
```

9.创建ajax过程
a.使用 new XMLHttpRequest 创建xhr对象
b.xhr.open 初始化请求参数
c.xhr.send 发送网络请求
d.xhr.onload 监听请求结果
e.xhr.onerror 请求中断等错误发生时的处理
```
const xhr = new XMLHttpRequest()
xhr.timeout = 5000
xhr.open('GET', 'hd.php')
xhr.send()
xhr.onload = function () {
    if (xhr.status == 200) {
        console.log(xhr.response)
    } else {
        console.log(`${xhr.status}:${xhr.statusText}`)
    }
}
xhr.onerror = function (error) {
    console.log(error)
}
```

10.渐进增强和优雅降级
渐进增强:
在网页开发中，渐进增强认为应该专注于内容本身。一开始针对低版本的浏览器构建页面，满足最基本的功能，再针对高级浏 览器进行效果，交互，追加各种功能以达到更好用户体验,换句话说，就是以最低要求，实现最基础功能为基本，向上兼容。
优雅降级:
在网页开发中，优雅降级指的是一开始针对一个高版本的浏览器构建页面，先完善所有的功能。然后针对各个不同的浏览器进行测试，修复，保证低级浏览器也有基本功能 就好，低级浏览器被认为“简陋却无妨 (poor, but passable)” 可以做一些小的调整来适应某个特定的浏览器。

11.在Bootstrap中，栅格系统的标准用法是啥？
栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。下面就介绍一下 Bootstrap 栅格系统的工作原理：

“行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。
. 通过“行（row）”在水平方向创建一组“列（column）”。
. 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。
. 类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。
. 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding。
. 负值的 margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。
. 栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。
. 如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。
. 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-md-* 栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-lg-* 不存在， 也影响大屏幕设备。

12.你觉得jQuery和Zepto源码有哪些地方写得好？
. jQuery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jQuery访问window对象的时候，就不同将作用域链退回顶层作用域了，从而可以更快的访问window对象
. jquery将一些原型属性和方法封装在了jquery.prototype中,为了缩短名称，又赋值给了jquery.fn
. 有一些数组或对象的方法经常能使用到，jquery将其保存为局部变量以提高访问速度
. jquery实现的链式调用可以节约代码，所返回的都是同一个对象，提高代码效率

Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。
设计的目的是提供jquery的类似的APIs，但并不是100%覆盖jquery为目的
Zepto的一些可选功能是专门针对移动端浏览器

13.浏览器页面有哪3层构成，分别是什么，作用又是什么？
结构层 html，表示层 css，行为层 js
html就是页面的具体内容，标签和含义
css就是样式的内容
js就是操作DOM,BOM和Event等等

14.HTML5的优点和缺点？
优点：
a.网络标准统一
b.多设备、跨平台
c.即时更新
d.提高可用性和改进用户的友好体验
e.有几个新的标签，这将有助于开发人员定义重要的内容
f.多媒体元素(视频和音频)
g.可以很好的替代Flash和Silverlight
h.涉及到网站的抓取和索引的时候，对于SEO很友好
i.被大量应用于移动应用程序和游戏(应用范围广)
缺点：
a.安全问题。容易被黑客利用，盗取用户信息
b.完善性 许多浏览器支持程度不一样
c.性能 某些平台的引擎问题导致性能差
d.浏览器兼容性 不支持低版本浏览器

15.介绍模块化的发展历程

16.对前端模块化的认识

17.javascript垃圾回收方法

18.TCP和UDP的区别

19.谈谈性能优化问题

20.什么事Etag?

21.javascript继承的6种方法

22.异步加载和延迟加载

23.ie各版本和chrom可以并行下载多少个资源

24.Flash,Ajax各自的优缺点，在使用中如何取舍?

25.快速排序的思想，并实现一个快排
