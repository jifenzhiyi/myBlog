一.v-if和v-for哪个优先级高
当两者作用在同一个元素上时
2.x版本中v-for优先
3.x版本中v-if优先

结论
1.从源码角度分析
2.如果同时出现。会浪费性能
3.尽量避免，可以在外层嵌套template，先进行v-if判断，或者过滤数据之后v-for循环

二.如何理解vue中的diff算法
源码分析1:必要性    lifecycle.js -> mountComponent
组件中可能存在很多个data中的key使用，通过diff算法可以判断谁发生了变化
源码分析2:执行方式   patch.js -> patchVnode
patchVnode是diff发生的地方，整体的策略：深度优先，同层比较
源码分析3:高效性     patch.js -> updateChildren

总结：
1.diff算法是虚拟DOM技术的必然产物：通过新旧虚拟DOM做对比（即diff）将变化的地方更新在真实DOM上；
另外，也需要diff高效的执行对比过程，从而降低时间复杂度为O(n)
2.vue2.x中为了降低Watch粒度，每个组件只有一个Watch与之对应，只有引入diff才能精确找到变化的地方
3.vue中diff执行的时刻是组件事例执行其更新函数时，它会比对上一次渲染结果oldVnode和新的渲染结果newVnode,此过程为patch
4.diff过程整体遵循深度优先，同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同的操作；
比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次比对尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；
借助key通常可以非常精确的找到相同节点，因此整个patch过程非常高效

三.谈一谈对组件化的理解
组件化的定义，优点，使用场景和注意事项等方面展开陈述，同时要强调vue中组件化的一些特点。

分析1:组件定义
Vue.component('comp', {
  template: '<div>This is a component.</div>'
})
<template>
  <div>
    This is a template.
  </div>
</template
备注：
vue-loader会编译template为render函数，最终导出的是组件配置对象
分析2:组件优点
维护性，测试性，复用性
分析3:组件化实现
构造函数 src/core/global-api/extend.js
实例化及挂载 src/core/vdom/patch.js -> createElm() 
// 149行 createComponent
// 创建组件实例后会进行挂载

总结：
1.组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之一，它使开发者使用小型，独立和可复用的组件来构建大型应用
2.组件化开发能大幅度提高效率，方便测试等等
3.组件使用可分类为：页面组件，业务组件，通用组件等等
4.vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架会生成其构造函数，它们基于vueComponent,扩展于Vue
5.vue中常见的组件化技术有: prop,自定义事件，插槽等等，用于通信和扩展
6.合理划分组件，有利于提高性能
7.高内聚，低耦合
8.遵循单向数据流的原则

四.谈一谈vue设计原则的理解
1.渐进式javaScript框架
与其它框架不同，Vue被设计为可以自底向上逐层应用。
Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目进行整合。
另一方面，当与现代化工具链以及各种支持类库结合使用时，Vue也完全能够提供驱动。

2.易用，灵活和高效
vue提供数据响应式，声明式模版语法和基于配置的组件系统等核心特性。
这些使我们只需要关注应用的核心业务即可，只要会写js,html和css就能轻松编写
渐进式框架的最大优点就是灵活，只要应用不大，一些核心特性就足够了。随着应用扩大再不断引入更多库和功能。
超快的虚拟DOM和Diff算法使我们的应用拥有极佳的性能表现。
随着vue本身的不断升级，会让项目更加的高效
