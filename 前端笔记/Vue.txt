一.v-if和v-for哪个优先级高
当两者作用在同一个元素上时
2.x版本中v-for优先
3.x版本中v-if优先

结论
1.从源码角度分析
2.如果同时出现。会浪费性能
3.尽量避免，可以在外层嵌套template，先进行v-if判断，或者过滤数据之后v-for循环

二.如何理解vue中的diff算法
源码分析1:必要性    lifecycle.js -> mountComponent
组件中可能存在很多个data中的key使用，通过diff算法可以判断谁发生了变化
源码分析2:执行方式   patch.js -> patchVnode
patchVnode是diff发生的地方，整体的策略：深度优先，同层比较
源码分析3:高效性     patch.js -> updateChildren

总结：
1.diff算法是虚拟DOM技术的必然产物：通过新旧虚拟DOM做对比（即diff）将变化的地方更新在真实DOM上；
另外，也需要diff高效的执行对比过程，从而降低时间复杂度为O(n)
2.vue2.x中为了降低Watch粒度，每个组件只有一个Watch与之对应，只有引入diff才能精确找到变化的地方
3.vue中diff执行的时刻是组件事例执行其更新函数时，它会比对上一次渲染结果oldVnode和新的渲染结果newVnode,此过程为patch
4.diff过程整体遵循深度优先，同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同的操作；
比较两组子节点是算法的重点，首先假设头尾节点可能相同做4次比对尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；
借助key通常可以非常精确的找到相同节点，因此整个patch过程非常高效

三.谈一谈对组件化的理解
组件化的定义，优点，使用场景和注意事项等方面展开陈述，同时要强调vue中组件化的一些特点。

分析1:组件定义
Vue.component('comp', {
  template: '<div>This is a component.</div>'
})
<template>
  <div>
    This is a template.
  </div>
</template
备注：
vue-loader会编译template为render函数，最终导出的是组件配置对象
分析2:组件优点
维护性，测试性，复用性
分析3:组件化实现
构造函数 src/core/global-api/extend.js
实例化及挂载 src/core/vdom/patch.js -> createElm() 
// 149行 createComponent
// 创建组件实例后会进行挂载

总结：
1.组件是独立和可复用的代码组织单元。组件系统是Vue核心特性之一，它使开发者使用小型，独立和可复用的组件来构建大型应用
2.组件化开发能大幅度提高效率，方便测试等等
3.组件使用可分类为：页面组件，业务组件，通用组件等等
4.vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架会生成其构造函数，它们基于vueComponent,扩展于Vue
5.vue中常见的组件化技术有: prop,自定义事件，插槽等等，用于通信和扩展
6.合理划分组件，有利于提高性能
7.高内聚，低耦合
8.遵循单向数据流的原则

四.谈一谈vue设计原则的理解
1.渐进式javaScript框架
与其它框架不同，Vue被设计为可以自底向上逐层应用。
Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目进行整合。
另一方面，当与现代化工具链以及各种支持类库结合使用时，Vue也完全能够提供驱动。

2.易用，灵活和高效
vue提供数据响应式，声明式模版语法和基于配置的组件系统等核心特性。
这些使我们只需要关注应用的核心业务即可，只要会写js,html和css就能轻松编写
渐进式框架的最大优点就是灵活，只要应用不大，一些核心特性就足够了。随着应用扩大再不断引入更多库和功能。
超快的虚拟DOM和Diff算法使我们的应用拥有极佳的性能表现。
随着vue本身的不断升级，会让项目更加的高效

五.谈谈对MVC,MVP和MVVM的理解
Web1.0时代
在1.0时，并没有前端的概念。
开发一个web应用多数采用ASP.NET/Java/PHP编写，
项目通常由多个aspx/jsp/php文件构成,每个文件中同时包含了HTM，CSS，JS，C#/Java/PHP代码，
系统整体架构简单快捷，但是，维护起来相当麻烦

为了开发更加便捷，代码更容易维护，前后端职责更清晰。便衍生出MVC开发模式和框架，前端展示以模版的形式出现。
典型的框架就是Spring,Structs,Hibernate.
使用这种分层架构，指责清晰，代码易维护。但这里的MVC仅限于后端，前后端形成了一定的分离，前端只完成后端开发中的View层。
但是，这种模式存在着一些：
1.前端页面开发效率不高
2.前后端职业不清

Web2.0时代
自从Gmail的出现，ajax技术开始风靡全球。有了ajax之后，前后端指责更加清晰。
通过ajax与后台服务器进行数据交换，前端开发人员，只需要开发页面这部分内容，数据由后台提供。
而且ajax可以使页面实现部分刷新，减少了服务端负载和流浪消耗，用户体验也更佳。
同时前端的类库也慢慢开始发展，(jQuery)
当然，此架构也存在问题：缺乏可行的开发模式承载更复杂的业务需求，页面内容都杂糅在一起，一旦应用规模增大，就会导致难以维护。

前后端分离后的架构演变--MVC，MVP和MVVM
MVC
前端的MVC与后端类似，具备着View,Controller和Model
Model:负责保存应用数据，与后端数据进行同步
Controller:负责业务逻辑，根据用户行为对Model数据进行修改
View:负责试图展示，将model中的数据可视化出来
这样的模型，理论上是可行的，但在实际开发中，并不会这样操作。导致开发非常的不灵活。

在实际场景中，我们往往会看到另一种模式，如backbone.js框架（相对灵活一些）
但是，这种灵活会导致严重的问题
1.数据流混乱
2.View比较庞大，而Controller比较单薄：由于多狠开发者都会在View中写一些逻辑代码，会导致View中的内容越来越庞大。

MVP
MVP和MVC很接近，P是指Presenter,可以理解为一个中间人，它负责View和Model之间的数据流动，防止两者直接交流
但是，随着应用逐渐变大，P的体积也会越来越大，变得难以维护。

MVVM
Model-View-ViewModel
ViewModel可以理解为在Presenter基础上的进阶版
ViewModel通过实现一套数据响应式机制自动响应Model中数据变化；
同时ViewModel会实现一套更新策略自动将数据变化转换为试图更新；
通过事件监听响应View中用户交互修改Model中数据
这样在ViewModel中就减少了大量Dom操作代码
MVVM在保持View和Model松耦合的同时，还减少了维护他们关系的代码，使用户专注于业务逻辑，兼顾开发效率和可维护性

总结：
这三者都是框架模式，它们设计的目标都是为了解决Model和View的耦合问题。使代码的可读性，可维护性更高一些。
它们都是时代的产物，是前端领域发展的进程。

MVC出现的时间比较早，它的优点是分层清晰，但是缺点也很明显，数据流混乱，灵活性带来的维护性问题
MVP是MVC的进化版，P作为中间层负责MV通信，解决了两者耦合的问题，但是相对的，P层越来越臃肿从而变的难以维护
MVVM模式在前端广泛应用，不仅解决了MV的耦合问题，还同时结局了维护两者映射关系的大量繁杂代码和DOM操作，
提高了开发效率，可读性，同时还保持了优越的性能表现

六.你了解哪些Vue性能优化方法？
1.路由懒加载
const router = new VueRouter({
  routes: [
    { path: '/foo', component: () => import('./Foo.vue') }
  ]
})
2.keep-alive缓存页面
<template>
  <div id="app">
    <keep-alive>
      <router-view />
    </keep-alive>
  </div>
</template>
3.使用v-show复用DOM
4.v-for遍历避免同时使用v-if
5.长列表性能优化
如果列表是存粹的数据展示，不会有任何的变化，就不需要做响应化
export defautl {
  data: () => ({ users: [] }),
  async created() {
    const users = await axios.get('/api/users');
    this.users = object.freeze(users);
  }
}
如果是大数据长列表，可采用虚拟滚动，只渲染部分区域内容
<recycle-scroller
  class="items"
  :items="items
  :items-size="24">
  <template v-slot="{item}">
    <FetchItemView
      :item="item"
      @vote="voteItem(item)"
      />
  </template>
</recycle-scroller>
参考vue-virtual-scroller,vue-virtual-scroll-list
6.事件的销毁
Vue组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。
定时器需要在beforeDestroy() {}中进行清除
7.图片懒加载
对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视内的图片先不做加载，等图片出现在可视化界面中才加载
<img v-lazy="/static/XXX.jpg" />
参考vue-lazyload
8.第三方库插件按需引入
类似element-ui，echart等等
9.无状态的组件标记为函数式组件
<template functional>
  <div class="cell"><h3>{{ title }}</h3></div>
</template>
<script>
export default {
  propst: ['title'],
}
</script>
10.子组件分割
<template>
  <div>
    <child1 />
    <child2 />
    <child3 />
  </div>
</template>
11.变量本地化
12.SSR

七.Vue3.0的新特性
根据尤大的PPT总结，Vue3.0改进主要几点：
1.更快
  虚拟DOM重写
  优化slots的生成
  静态树提升
  静态属性提升
  基于Proxy的响应式系统
2.更小：通过摇树优化核心库体积
3.更容易维护：TypeScript + 模块化
4.更加友好
  跨平台：编译器核心和运行时核心与平台无关，使Vue更容易与任何平台Web，Android，iOS一起使用
5.更容易使用
  改进的TS支持，编辑器能提供强有力的类型检查和错误及警告
  更好的调试支持
  独立的响应化模块
  Composition api

八.说一说vuex使用及理解？
官网定义
Vuex是一个专门为Vue.js开发的状态管理模式。它采用集中式存储管理应用的所有组件状态，并以相应的规则保证状态以一种可预测的方式发生变化。
解决的问题
组件之间的状态共享，保持状态的一致，使我们的代码结构清晰且容易维护

九.vue组件之间的通信方式
vue是组件化开发框架，所以对于vue来说组件之间的通信非常重要

8种
props $emit/$on $children/$parent $attrs/$listeners ref $root eventbus vuex

other
provide/inject

父子通信，兄弟组件，跨层级关系

十.vue-router如何保护指定路由的安全
路由守卫
1.vue-router中通常使用路由守卫，通过设置路由导航钩子函数的方式添加守卫函数，在里面判断用户登录的状态和权限，从而达到保护指定路由的目的
2.具体实现有几个层级：全局前置守卫，路由独享守卫，路由独享守卫和组件内的守卫
  各个之间的区别：
  a.作用范围
  b.组件实例的获取（组件内的守卫才能获取到）
  c.名称/数量/顺序
3.这些钩子函数之所以可以生效，和vue-router工作方式有关。当路由发生变化的时候才会执行
4.前后端的路由一样吗？不太一样，后端所对应的某个具体的函数接口。前端的路由是根据不同的路由显示不同的组件模块
5.利用router-view来动态相应的显示路由相关的组件模块
6.next是一个高阶函数

十一.nextTick是什么？实现原理是什么？
Vue.nextTick([callback, context]) 全局API
在下次DOM更新循环之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。
// 修改数据
this.msg = 'Hello';
// DOM还没有更新
Vue.nextTick(function () {
  // DOM更新了
})

十二.vue响应式的理解?
答题思路：
1.什么是响应式
2.为什么需要响应式
3.带来的好处
4.如何实现，有哪些优点
5.vue3的响应式变化

1.所谓数据响应式就是能够使数据变化可以被检测到并对这种变化作出响应的机制。
2.mvvm框架中要解决的核心问题就是连接数据层和视图层，通过数据驱动应用，数据变化，视图变化，要做到这一点需要数据响应式。
3.vue中，通过数据响应式加上虚拟DOM和patch算法，使我们只需要操作数据，完全不用接触繁琐的dom操作，从而大大提升开发效率，降低开发难度。
4.vue2中数据响应式根据数据类型做不同的处理，如果是对象则采用Object.defineProperty()的方法定义数据拦截，当数据被访问或方式变化时候，我们感知并作出相应；
  如果是数组通过覆盖该数组原型的方法，扩展它的7个变更方法，使这些方法可以额外的做更新通知，从而作出响应。
  缺点：初始化的递归遍历会造成性能损失；新增和删除属性时需要用户Vue.set/delete这样的api才能生效；es6中的Map,Set数据结构不支持；
5.vue3的实现：利用ES6的Proxy机制代理响应化的数据，不需要使用特殊的api,性能和内存消耗得到了大幅改善；
